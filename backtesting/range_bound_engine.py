"""\n區間震盪策略回測引擎\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict\nimport plotly.graph_objects as go\n\n\nclass RangeBoundBacktestEngine:\n    def __init__(\n        self,\n        initial_capital: float = 10000.0,\n        leverage: float = 1.0,\n        fee_rate: float = 0.0006\n    ):\n        self.initial_capital = initial_capital\n        self.leverage = leverage\n        self.fee_rate = fee_rate\n        self.trades = []\n        self.equity_curve = []\n        \n    def run_backtest(self, signals_dict: Dict[str, pd.DataFrame]) -> Dict:\n        """執行回測"""\n        for symbol, df in signals_dict.items():\n            balance = self.initial_capital\n            position = None\n            \n            for i in range(50, len(df)):\n                row = df.iloc[i]\n                current_price = row['close']\n                current_time = row.get('open_time', i)\n                \n                # 計算權益\n                current_equity = balance\n                if position:\n                    if position['type'] == 'long':\n                        pnl = (current_price - position['entry']) * position['size']\n                    else:\n                        pnl = (position['entry'] - current_price) * position['size']\n                    current_equity += pnl\n                \n                self.equity_curve.append({\n                    'time': current_time,\n                    'equity': current_equity,\n                    'balance': balance\n                })\n                \n                # 檢查出場\n                if position:\n                    hit_sl = (position['type'] == 'long' and row['low'] <= position['sl']) or \\\n                             (position['type'] == 'short' and row['high'] >= position['sl'])\n                    \n                    hit_tp = (position['type'] == 'long' and row['high'] >= position['tp']) or \\\n                             (position['type'] == 'short' and row['low'] <= position['tp'])\n                    \n                    if hit_sl:\n                        exit_price = position['sl']\n                        exit_reason = 'SL'\n                    elif hit_tp:\n                        exit_price = position['tp']\n                        exit_reason = 'TP'\n                    else:\n                        continue\n                    \n                    # 計算損益\n                    if position['type'] == 'long':\n                        pnl = (exit_price - position['entry']) * position['size']\n                    else:\n                        pnl = (position['entry'] - exit_price) * position['size']\n                    \n                    fee = exit_price * position['size'] * self.fee_rate\n                    pnl -= fee\n                    balance += pnl\n                    \n                    duration_min = (current_time - position['entry_time']).total_seconds() / 60 if hasattr(current_time - position['entry_time'], 'total_seconds') else 0\n                    \n                    self.trades.append({\n                        'symbol': symbol,\n                        '進場時間': position['entry_time'],\n                        '離場時間': current_time,\n                        '方向': '做多' if position['type'] == 'long' else '做空',\n                        '進場價格': position['entry'],\n                        '離場價格': exit_price,\n                        '損益(USDT)': pnl,\n                        '損益率': f"{(pnl / (position['entry'] * position['size'] / self.leverage)) * 100:.2f}%",\n                        '離場原因': exit_reason,\n                        '持倉時長(分)': duration_min\n                    })\n                    \n                    position = None\n                    continue\n                \n                # 檢查進場\n                if position is None:\n                    signal = row.get('signal', 0)\n                    \n                    if signal == 1:  # 做多\n                        entry_price = current_price\n                        position_value = balance * self.leverage\n                        position_size = position_value / entry_price\n                        \n                        open_fee = entry_price * position_size * self.fee_rate\n                        balance -= open_fee\n                        \n                        position = {\n                            'type': 'long',\n                            'entry': entry_price,\n                            'size': position_size,\n                            'sl': row.get('stop_loss', entry_price * 0.98),\n                            'tp': row.get('take_profit', entry_price * 1.02),\n                            'entry_time': current_time\n                        }\n                    \n                    elif signal == -1:  # 做空\n                        entry_price = current_price\n                        position_value = balance * self.leverage\n                        position_size = position_value / entry_price\n                        \n                        open_fee = entry_price * position_size * self.fee_rate\n                        balance -= open_fee\n                        \n                        position = {\n                            'type': 'short',\n                            'entry': entry_price,\n                            'size': position_size,\n                            'sl': row.get('stop_loss', entry_price * 1.02),\n                            'tp': row.get('take_profit', entry_price * 0.98),\n                            'entry_time': current_time\n                        }\n            \n            # 強制平倉\n            if position:\n                final_price = df.iloc[-1]['close']\n                if position['type'] == 'long':\n                    pnl = (final_price - position['entry']) * position['size']\n                else:\n                    pnl = (position['entry'] - final_price) * position['size']\n                \n                fee = final_price * position['size'] * self.fee_rate\n                pnl -= fee\n                balance += pnl\n        \n        # 計算統計\n        return self._calculate_metrics()\n    \n    def _calculate_metrics(self) -> Dict:\n        """計算績效指標"""\n        if not self.trades:\n            return {\n                'total_trades': 0,\n                'win_rate': 0,\n                'final_equity': self.initial_capital,\n                'total_return_pct': 0,\n                'profit_factor': 0,\n                'sharpe_ratio': 0,\n                'max_drawdown_pct': 0,\n                'avg_duration_min': 0\n            }\n        \n        trades_df = pd.DataFrame(self.trades)\n        equity_df = pd.DataFrame(self.equity_curve)\n        \n        winning_trades = trades_df[trades_df['損益(USDT)'] > 0]\n        losing_trades = trades_df[trades_df['損益(USDT)'] < 0]\n        \n        win_rate = len(winning_trades) / len(trades_df) * 100 if len(trades_df) > 0 else 0\n        \n        total_profit = winning_trades['損益(USDT)'].sum() if len(winning_trades) > 0 else 0\n        total_loss = abs(losing_trades['損益(USDT)'].sum()) if len(losing_trades) > 0 else 0\n        profit_factor = total_profit / total_loss if total_loss > 0 else float('inf')\n        \n        final_equity = equity_df['equity'].iloc[-1]\n        total_return_pct = (final_equity / self.initial_capital - 1) * 100\n        \n        # 最大回撒\n        equity_series = equity_df['equity']\n        running_max = equity_series.expanding().max()\n        drawdown = (equity_series - running_max) / running_max\n        max_drawdown_pct = drawdown.min() * 100\n        \n        # 夏普比率\n        returns = equity_series.pct_change().dropna()\n        sharpe_ratio = (returns.mean() / returns.std() * np.sqrt(96 * 365)) if returns.std() > 0 else 0\n        \n        # 平均持倉時長\n        avg_duration = trades_df['持倉時長(分)'].mean()\n        \n        return {\n            'total_trades': len(trades_df),\n            'win_rate': win_rate,\n            'final_equity': final_equity,\n            'total_return_pct': total_return_pct,\n            'profit_factor': profit_factor,\n            'sharpe_ratio': sharpe_ratio,\n            'max_drawdown_pct': max_drawdown_pct,\n            'avg_duration_min': avg_duration\n        }\n    \n    def get_trades_dataframe(self) -> pd.DataFrame:\n        """獲取交易明細"""\n        return pd.DataFrame(self.trades)\n    \n    def plot_equity_curve(self) -> go.Figure:\n        """繪製權益曲線"""\n        equity_df = pd.DataFrame(self.equity_curve)\n        \n        fig = go.Figure()\n        fig.add_trace(go.Scatter(\n            x=equity_df['time'],\n            y=equity_df['equity'],\n            mode='lines',\n            name='權益',\n            line=dict(color='green', width=2)\n        ))\n        \n        fig.add_hline(\n            y=self.initial_capital,\n            line_dash='dash',\n            line_color='gray',\n            annotation_text='初始資金'\n        )\n        \n        fig.update_layout(\n            title='策略 C 權益曲線',\n            xaxis_title='時間',\n            yaxis_title='權益 (USDT)',\n            hovermode='x unified',\n            height=400\n        )\n        \n        return fig\n