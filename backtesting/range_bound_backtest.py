"""\n策略 C 回測引擎\n\n支持功能:\n- 逐根 K 線迭代\n- 止損止盈檢查\n- 手續費計算 (Binance Taker: 0.06%)\n- 績效統計 (勝率、盈虧比、最大回撒)\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, List\nfrom models.range_bound_strategy import RangeBoundStrategy\n\n\nclass RangeBoundBacktest:\n    \"\"\"\n    區間震盪策略回測引擎\n    \"\"\"\n    \n    def __init__(\n        self,\n        initial_capital: float = 10000.0,\n        leverage: float = 1.0,\n        fee_rate: float = 0.0006  # Binance Taker 0.06%\n    ):\n        self.initial_capital = initial_capital\n        self.leverage = leverage\n        self.fee_rate = fee_rate\n        \n    def run(self, df: pd.DataFrame, strategy: RangeBoundStrategy) -> Dict:\n        \"\"\"\n        執行回測\n        \n        Args:\n            df: K線數據 (must have OHLCV columns)\n            strategy: RangeBoundStrategy 實例\n            \n        Returns:\n            {\n                'trades': DataFrame,\n                'equity_curve': DataFrame,\n                'stats': Dict\n            }\n        \"\"\"\n        balance = self.initial_capital\n        position = None  # {'type': 'long'/'short', 'entry': price, 'size': qty, 'sl': price, 'tp': price}\n        \n        trades = []\n        equity_curve = []\n        \n        # 逐根 K 線迭代 (跳過前 50 根確保指標充分)\n        for i in range(50, len(df)):\n            current_bar = df.iloc[:i+1]  # 只使用到當前的數據\n            row = current_bar.iloc[-1]\n            \n            current_price = row['close']\n            current_time = row.get('open_time', i)\n            \n            # 計算當前權益\n            current_equity = balance\n            if position:\n                if position['type'] == 'long':\n                    pnl = (current_price - position['entry']) * position['size']\n                else:\n                    pnl = (position['entry'] - current_price) * position['size']\n                current_equity += pnl\n            \n            equity_curve.append({\n                'time': current_time,\n                'equity': current_equity,\n                'balance': balance\n            })\n            \n            # === 檢查出場條件 ===\n            if position:\n                # 1. 止損\n                hit_sl = (position['type'] == 'long' and row['low'] <= position['sl']) or \\\n                         (position['type'] == 'short' and row['high'] >= position['sl'])\n                \n                # 2. 止盈\n                hit_tp = (position['type'] == 'long' and row['high'] >= position['tp']) or \\\n                         (position['type'] == 'short' and row['low'] <= position['tp'])\n                \n                exit_price = None\n                exit_reason = None\n                \n                if hit_sl:\n                    exit_price = position['sl']\n                    exit_reason = 'Stop Loss'\n                elif hit_tp:\n                    exit_price = position['tp']\n                    exit_reason = 'Take Profit'\n                \n                # 執行出場\n                if exit_price:\n                    # 計算損益\n                    if position['type'] == 'long':\n                        pnl = (exit_price - position['entry']) * position['size']\n                    else:\n                        pnl = (position['entry'] - exit_price) * position['size']\n                    \n                    # 扣除手續費\n                    fee = exit_price * position['size'] * self.fee_rate\n                    pnl -= fee\n                    \n                    balance += pnl\n                    \n                    trades.append({\n                        'time': current_time,\n                        'type': f\"CLOSE_{position['type'].upper()}\",\n                        'price': exit_price,\n                        'pnl': pnl,\n                        'balance': balance,\n                        'reason': exit_reason\n                    })\n                    \n                    position = None\n                    continue\n            \n            # === 檢查進場條件 ===\n            if position is None:\n                signal = strategy.generate_signal(current_bar)\n                \n                if signal['signal'] in ['buy', 'sell']:\n                    entry_price = current_price\n                    \n                    # 位置大小計算\n                    position_value = balance * self.leverage\n                    position_size = position_value / entry_price\n                    \n                    # 扣除開倉手續費\n                    open_fee = entry_price * position_size * self.fee_rate\n                    balance -= open_fee\n                    \n                    position = {\n                        'type': 'long' if signal['signal'] == 'buy' else 'short',\n                        'entry': entry_price,\n                        'size': position_size,\n                        'sl': signal['stop_loss'],\n                        'tp': signal['take_profit']\n                    }\n                    \n                    trades.append({\n                        'time': current_time,\n                        'type': f\"OPEN_{position['type'].upper()}\",\n                        'price': entry_price,\n                        'sl': signal['stop_loss'],\n                        'tp': signal['take_profit'],\n                        'balance': balance,\n                        'reason': signal.get('reason', '')\n                    })\n        \n        # 強制平倉 (如果還有持倉)\n        if position:\n            final_price = df.iloc[-1]['close']\n            if position['type'] == 'long':\n                pnl = (final_price - position['entry']) * position['size']\n            else:\n                pnl = (position['entry'] - final_price) * position['size']\n            \n            fee = final_price * position['size'] * self.fee_rate\n            pnl -= fee\n            balance += pnl\n            \n            trades.append({\n                'time': df.iloc[-1].get('open_time', len(df)-1),\n                'type': 'FORCE_CLOSE',\n                'price': final_price,\n                'pnl': pnl,\n                'balance': balance,\n                'reason': 'End of backtest'\n            })\n        \n        # 計算統計\n        trades_df = pd.DataFrame(trades)\n        equity_df = pd.DataFrame(equity_curve)\n        stats = self._calculate_stats(trades_df, equity_df)\n        \n        return {\n            'trades': trades_df,\n            'equity_curve': equity_df,\n            'stats': stats\n        }\n    \n    def _calculate_stats(self, trades_df: pd.DataFrame, equity_df: pd.DataFrame) -> Dict:\n        \"\"\"\u8a08算績效指標\"\"\"\n        if trades_df.empty:\n            return self._empty_stats()\n        \n        # 篩選平倉交易\n        closed_trades = trades_df[trades_df['type'].str.contains('CLOSE')]\n        \n        if closed_trades.empty:\n            final_balance = trades_df.iloc[-1]['balance'] if 'balance' in trades_df.columns else self.initial_capital\n            return self._partial_stats(final_balance)\n        \n        # 基本統計\n        total_trades = len(closed_trades)\n        winning_trades = closed_trades[closed_trades['pnl'] > 0]\n        losing_trades = closed_trades[closed_trades['pnl'] < 0]\n        \n        win_rate = len(winning_trades) / total_trades * 100 if total_trades > 0 else 0\n        avg_profit = winning_trades['pnl'].mean() if len(winning_trades) > 0 else 0\n        avg_loss = losing_trades['pnl'].mean() if len(losing_trades) > 0 else 0\n        \n        total_profit = winning_trades['pnl'].sum() if len(winning_trades) > 0 else 0\n        total_loss = abs(losing_trades['pnl'].sum()) if len(losing_trades) > 0 else 0\n        profit_factor = total_profit / total_loss if total_loss > 0 else float('inf')\n        \n        # 最大回撒\n        equity_series = equity_df['equity']\n        running_max = equity_series.expanding().max()\n        drawdown = (equity_series - running_max) / running_max\n        max_drawdown = drawdown.min() * 100\n        \n        final_balance = trades_df.iloc[-1]['balance']\n        total_return = final_balance - self.initial_capital\n        return_pct = (final_balance / self.initial_capital - 1) * 100\n        \n        return {\n            'total_trades': total_trades,\n            'winning_trades': len(winning_trades),\n            'losing_trades': len(losing_trades),\n            'win_rate': win_rate,\n            'avg_profit': avg_profit,\n            'avg_loss': avg_loss,\n            'profit_factor': profit_factor,\n            'max_drawdown': max_drawdown,\n            'final_balance': final_balance,\n            'total_return': total_return,\n            'return_pct': return_pct\n        }\n    \n    def _empty_stats(self) -> Dict:\n        \"\"\"\u7a7a統計\"\"\"\n        return {\n            'total_trades': 0,\n            'winning_trades': 0,\n            'losing_trades': 0,\n            'win_rate': 0,\n            'avg_profit': 0,\n            'avg_loss': 0,\n            'profit_factor': 0,\n            'max_drawdown': 0,\n            'final_balance': self.initial_capital,\n            'total_return': 0,\n            'return_pct': 0\n        }\n    \n    def _partial_stats(self, final_balance: float) -> Dict:\n        \"\"\"\u90e8分統計 (沒有平倉)\"\"\"\n        return {\n            'total_trades': 0,\n            'winning_trades': 0,\n            'losing_trades': 0,\n            'win_rate': 0,\n            'avg_profit': 0,\n            'avg_loss': 0,\n            'profit_factor': 0,\n            'max_drawdown': 0,\n            'final_balance': final_balance,\n            'total_return': final_balance - self.initial_capital,\n            'return_pct': (final_balance / self.initial_capital - 1) * 100\n        }\n